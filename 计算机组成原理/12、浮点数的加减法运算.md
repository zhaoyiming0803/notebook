任意的浮点数都可以表示为：N = S * r ^ j

- 对阶：使得两个浮点数阶码一致，使得尾数可以进行运算

浮点数尾数运算简单

浮点数位数实际小数位与阶码有关

阶码按小阶看齐大阶的原则

- 尾数求和

使用反码运算

减法按照加法进行运算

- 尾数规格化

如果求和后的尾数补码规不符合以下两种情况之一（即：符号位与最高位不一致）

S[补] = 00.1xxxx（S>0）

S[补] = 11.0xxxx（S<0）

则需要进行左移或右移同时阶码相应变化，以满足规格化

- 舍入

溢出的时候，需要右移

尾数规格化右移需要进行【舍入】操作

0舍1入法（二进制的四舍五入法）

S[补] = 10.101101111

双符号位不一致，说明溢出了，要进行右移的操作，右移之后的值为：

S[补] = 11.010110111

最末位的1没有办法存储，所以要舍去（如果最末位是0则不需要舍去），最后值为：

S[补] = 11.01011011

舍去了1，然后再加1，最后的值为：

S[补] = 11.01011100

- 溢出判断