JavaScript 只有基本类型 number，没有 int 、float 、double 之分，只要是数字，则一律按照浮点数来处理。在某种情况下，就会导致运算不精确的问题。

事实上，不仅是 JavaScript，其他采用『IEEE754 浮点数标准』的语言都有这种问题。

JavaScript 引擎在做数学计算的时候，先把数字转为二进制，然后用二进制进行运算，最后将运算的结果转为十进制。

比如：

十进制 150 转二进制的计算过程：

150 / 2  商 75  余 0
75  / 2  商 37  余 1
37  / 2  商 18  余 1
18  / 2  商 9   余 0
9   / 2  商 4   余 1
4   / 2  商 2   余 0
2   / 2  商 1   余 0
1   / 2  商 0   余 1

最后将余数倒序排：10010110，用科学记数法表示：2^8*0.10010110

十进制 0.1 转二进制的计算过程：

0.1 = 0 + 0.1

整数部分 0 的二进制数为 0，小数部分 0.1 的二进制转换过程是：

0.1 * 2 = 0.2  整数 0，小数 0.2
0.2 * 2 = 0.4  整数 0，小数 0.4
0.4 * 2 = 0.8  整数 0，小数 0.8
0.8 * 2 = 1.6  整数 1，小数 0.6
0.6 * 2 = 1.2  整数 1，小数 0.2
0.2 * 2 = 0.4  整数 0，小数 0.4
0.4 * 2 = 0.8  整数 0，小数 0.8
... 循环以上值

所以，最后十进制数 0.1 对应的二进制数为：整数 0 + 小数 0.0001100110011001100（循环1100）。

可以看到十进制数 0.1 对应的二进制数是无穷尽的。

因为 JavaScript 采用的 IEEE754 浮点数表示法具体为：

采用大端表示，高位在左，低位在右

sign(1)  exponent(2~12 ) fraction(13~64)          

- 符号位：高位第 1 位，sign 部分
- 指数位：高位第 2~12 位，exponent 部分
- 尾数位：剩下的 fraction 部分

从上面小数的乘二取整演算中可以看到，有些小数对应的二进制数是无法写全的，比如 0.1，而 fraction 尾数部分有要求，只允许 52 位，超过部分进一舍零。

因此造成了小数计算精度丢失的问题，如：

0.1 -> 0.000110011001100110011001100110011001100110011001100110B

0.2 -> 0.001100110011001100110011001100110011001100110011001101B

最后相加结果为：0.0100110011001100110011001100110011001100110011001101B

将截断之后的二进制数字再转换为十进制，就成了0.30000000000000004，所以在计算时产生了误差。

这就是 0.1 + 0.2 != 0.3 的原因。