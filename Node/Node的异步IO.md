### Node 事件循环的流程

1、在进程启动时，Node 会创建一个类似于 while (true) 的循环，没执行一次循环体的过程就是一次 tick。

2、每个 tick 的过程就是查看是否有事件待处理，如果有就取出事件及相关的回调函数，然后进入下一个循环，如果不再有事件处理，就退出进程。

### 每个 tick 的过程中，如何判断是否有事件需要处理？

1、每个事件循环中有一个或多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。

2、在 Node 中，事件主要来源于网络请求、文件的 I/O 等。这些事件对应的观察者有文件 I/O观察者，网络 I/O观察者。

3、事件循环使一个典型的生产者/消费者模型。异步 I/O、网络请求等则是事件的生产者，源源不断为 Node 提供不同类型的事件，这些事件被传递到对应的观察者哪里，事件循环则从观察者哪里取出事件并处理。

4、在 windows 下，这个循环基于 IOCP 创建，在 *nix 下基于多线程创建。

### 整个异步 IO 的流程

简单来说，阻塞 I/O 就是当用户发一个读取文件描述符的操作的时候，进程就会被阻塞，知道要读取的数据全部准备好返回给用户，这时候进程才会接触 block 的状态。

而非阻塞 I/O 则是用户发起一个读取文件的描述符操作的时候，函数立即返回，不做任何等待，进程继续执行，但是程序如何知道要读取的数据已经准备好了呢？最简单的方法就是轮询。

除此之外，还有一种叫做 I/O 多路复用的模式，就是用一个阻塞函数同时监听多个文件描述符，当其中有一个文件描述符准备好了，就马上返回，在 linux 下，select、poll、epoll 都提供了 IO 多路复用的功能。

非阻塞 I/O 都不阻塞了为什么不是异步 I/O 呢？其实当非阻塞 I/O 准备好数据之后还是要阻塞进程去内核拿数据的，所以算不上异步 I/O。

### 异步 I/O 结合事件循环

因为是单线程的，所以当顺序执行js文件中的代码的时候，事件循环是被暂停的。

当主线程上的js代码执行完以后，事件循环开始运行，并从消息队列中取出消息，开始执行回调函数

因为是单线程的，所以当回调函数被执行的时候，事件循环是被暂停的

当涉及到I/O操作的时候，nodejs会开一个独立的线程来进行异步I/O操作，操作结束以后将消息压入消息队列。

参考代码：

``` javascript
var fs = require('fs');
var debug = require('debug')('example1');
 
debug("begin");
 
fs.readFile('package.json', 'utf-8', function (err, data) {
  if(err)  
    debug(err);
  else
    debug('get file content');
});
 
setTimeout(function(){
  debug('timeout2');
});
 
debug('end');
```

上述代码执行顺序如下：

同步执行debug("begin")

异步调用fs.readFile()，此时会开一个新的线程去进行异步I/O操作

异步调用setTimeout()，马上将超时信息压入到消息队列中

同步调用debug("end")

开启事件循环，弹出消息队列中的信息(目前是超时信息)

然后执行信息对应的回调函数(事件循环又被暂停)

回调函数执行结束后，开始事件循环(目前消息队列中没有任何东西，文件还没读完)

异步I/O读取文件完毕，将消息压入消息队列(消息中含有文件内容或者是出错信息)

事件循环取得消息，执行回调

程序退出。
